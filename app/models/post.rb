class Post < ActiveRecord::Base
  #include ActionView::Helpers::TextHelper
  #include ActionView::Helpers::UrlHelper

  has_paper_trail

  self.per_page = 10

  belongs_to :user, :counter_cache => true
  belongs_to :board_thread, :counter_cache => :posts_count
  belongs_to :parent_post, :class_name => 'Post', :foreign_key => 'parent_id'

  has_many :child_posts, :class_name => 'Post', :foreign_key => 'parent_id'
  has_many :reports
  has_many :likes
  has_many :images, :dependent => :destroy
  accepts_nested_attributes_for :images, :reject_if => proc { false }, :allow_destroy => true

  validates :text, :length => { :minimum => 20,:maximum => 10000 }, :on => :create

  acts_as_indexed :fields => [:text, :subject, :namespace_name, :user_name]

  scope :root_posts, -> { where(parent_id: nil) }

  after_save :clean_up
  after_touch :clean_up
  after_destroy :update_hierarchy

  def update_hierarchy
    board_thread.touch
  end

  def image_offset
    super()
  end

  def subject
    board_thread.title
  end

  def namespace_name
    board_thread.name_space.name
  end

  def move_to(board_thread_id)
    if BoardThread.exists?(board_thread_id)
      move_post_to_thread(self, board_thread_id)
      BoardThread.find(board_thread_id).generate_sprites
      board_thread.generate_sprites
      return true
    end
    return false
  end

  def move_post_to_thread(post, board_thread_id, remove_parent = true)
    post.child_posts.each do |child|
      move_post_to_thread child, board_thread_id, false
    end
    post.images.each do |image|
      image.board_thread_id = board_thread_id
      image.save
    end
    post.board_thread_id = board_thread_id
    post.parent_id = nil if remove_parent
    post.save
  end

  def image_sample
    count = images.count
    return images.to_a if count < 5
    result = []
    result << images.first
    result << images.offset(count / 3).take(1)
    result << images.offset(2 * count / 3).take(1)
    result << images.last
    result
  end

  def clean_up
    File.delete(zip_file_name) if File.exist? zip_file_name
  end

  def user_name
    user.name
  end

  def clean_up
    File.delete(zip_file_name) if File.exist? zip_file_name
  end

  def zip_file_name
    File.join(Rails::root, 'uploads', 'zips', 'post',"#{id}.zip")
  end

  def create_zip
    FileUtils.mkdir_p(File.dirname(zip_file_name))
    File.delete(zip_file_name) if File.exist? zip_file_name

    Zip::File.open(zip_file_name, Zip::File::CREATE) do |zip_file|
      images.each do |image|
        begin
          zip_file.add(File.join(board_thread.title, image.name), File.join(Rails::root, image.image_url(nil)))
        rescue Zip::ZipEntryExistsError
          zip_file.add(File.join(board_thread.title, image.id.to_s, image.name), File.join(Rails::root, image.image_url(nil)))
        end
      end
      create_info_file(zip_file)
    end
    FileUtils.chmod(0644, zip_file_name)
  end

  def create_info_file(zip_file)
    zip_file.get_output_stream("Info-#{board_thread.title}.txt") do |os|
      os.puts 'This zip file is generated by the lolib board!'
      os.puts ''
      os.puts 'Full set name: ' + board_thread.name_space.full_path + ' / ' + board_thread.title + ' / Post #' + id.to_s
      os.puts ('-' * 80)
      os.puts text
    end
  end

  handle_asynchronously :create_zip
end
